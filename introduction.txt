
why data strutures ?
data structures is a way of organizing data so that it can be used effectively 
fast and powerful algorithm 
help to manage and organize data

abstract data type can have different type of implementation ds

big o talks about what heppens when n becomes big

static and dynamic arrays 

array - fixed leangth container containing n elements indexable from the range [0,n-1](indexable meaning each slot can be referenced with a number)
indexing starts at 0 and ends at n-1

where these are used
-sorting and accesing sequential data
-temporaray storage
-arrays and buffers( to read small chunks)
-lookup tables due to indexing 

static array (fixed size container )
(o(1),
no change in size 

dynamic array ( can acess , search ,insertion ,appending  and deletion )
can grow in size and even shrink 
how it is done ?
every time you add a new element more than the actual created size 
move the elements to static array
double the size
then add new element 



1.Question1 
Explain why each of the above two functions are constant time and what that means?

def pick_second(lst):
    return lst[1]

def add_and_print():
    x = 1
    x += 1
    print(x)


Here in the first function we are trying to return a  a fixed position list meaning we are returning a value so python will perform one direction lookup in memory weather it is a 3 elements or 3 million elements 
In the second function we are setting value 1 and adding 1  next step so same three steps nothing grows or shrink so runtime stays flat as the input grows which is always a constant bound --O(1)


2.Question2
Explain why each of the above two functions are linear time and what that means?
def count_up(N):
    for _ in range(N):
        pass

def insert_front(lst):
    lst.insert(0, 10)


In the first for loop we are running N iterations where each one does a constant time increment so total work is proportional to N
In the Second function python shifts every existing element one slot to the right and if the list holds N elements that shift touches all N of them meaning the cost is growing linearly with N

If N times the input size then the runtime will also increase N time so works directly with N  --O(N)


3.Question3
Explain why each of the above two functions are quadratic time and what that means?
def double_loop(N):
    for _ in range(N):       # outer
        for _ in range(N):   # inner
            pass

def many_front_inserts(lst):
    for item in lst:         # runs N times
        lst.insert(0, item)  # each insert shifts N items

In the first nested loop outer loop run N times and the inner loop run N times
meaning so total work would be N*N 
In the second nested loop the outer for loop run N times and every call to insertion is itself  N shift so the total work would be N*N  which is a Quadratic time complexity 
For larger inputs this becomes expensive quickly - --O(N^2) 

4.Question4
What is the time complexity of the above code and why?
def skip_by_k(N, k):
    for _ in range(N, 1, k):
        pass


Here the number of iteration in the for loop are (n-1)/k  so we count down until 1 but coming to time we still need to touch each step and number of steps is proportional to N even though divided by K so we can consider this one as linear -O(N)

5.Question5
Explain the time complexity of the above code?
def nested_steps(N):
    for _ in range(N, 1, 3):   # about N/3 times
        for _ in range(N, 1, 2):  # about N/2 times
            pass


Here in the first for loop number of iteration in the for loop are (n-1)/3  so we count down until 1 but coming to time we still need to touch each step and number of steps is proportional to N even though divided by 3 so we can consider this one as linear -O(N) 
and this repeats same in the second for loop similar iteration but this time with two so number of iterations would be n-1/2 where the total work would be n/3*n/2  which comes down to --O(N^2) 

6.Question6
Explain the time complexity of the above code. What is the give away sign for recognizing this time complexity?

def multiply_until(N):
    i = 1
    while i < N:
        i *= 2


Here the loop is utilizing while loop after 1 the values Starts doubling util it is equal or greater than N 
If N is  8 we will have 3 steps ,64 ->6 ,4096 -> 12 
so steps multiply rather than add and it takes  only a handful of doublings to explode past huge numbers  so logarithmic -- O(LOG N)
  

